<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Smart Librarian ‚Äî RAG + TTS/STT + Images + Streaming</title>
  <style>
    :root {
      --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --fg:#e5e7eb; --accent:#22d3ee; --accent-2:#38bdf8;
      --bubble-user:#1f2937; --bubble-bot:#0b1220; --border:#1f2937;
    }
    * { box-sizing: border-box; }
    body { margin:0; background: radial-gradient(1200px 600px at 20% -10%, #0b1220, #0f172a 60%), linear-gradient(180deg, #0f172a 0, #0b1020 100%); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    .container { max-width: 980px; margin: 0 auto; padding: 24px; }
    .header { display:flex; align-items:center; gap:12px; padding: 8px 0 20px; }
    .brand { font-weight:700; letter-spacing:0.2px; font-size: 22px; }
    .pill { border:1px solid var(--border); background: rgba(255,255,255,0.02); color: var(--muted); padding:6px 10px; border-radius:999px; font-size:12px; }
    .chat { background: rgba(255,255,255,0.02); border:1px solid var(--border); border-radius:16px; min-height: 60vh; padding:20px; display:flex; flex-direction:column; gap:14px; }
    .msg { display:flex; gap:10px; align-items:flex-start; }
    .avatar { flex:0 0 36px; height:36px; width:36px; border-radius:8px; display:grid; place-items:center; font-size:18px; background: linear-gradient(135deg, #0ea5e9, #22d3ee); }
    .avatar.user { background: linear-gradient(135deg, #6366f1, #a78bfa); }
    .bubble { padding:12px 14px; border-radius:12px; border:1px solid var(--border); max-width: 75%; line-height: 1.55; white-space:pre-wrap; }
    .bubble.user { background: var(--bubble-user); }
    .bubble.bot { background: var(--bubble-bot); }
    .actions { display:flex; gap:8px; margin:6px 0 0 46px; flex-wrap:wrap; }
    .sources { margin-top:6px; font-size:12px; color: var(--muted); border-left:3px solid var(--accent-2); padding-left:10px; margin-left:46px; }
    .composer { display:flex; gap:10px; margin-top: 14px; flex-direction:column; }
    .input { flex:1; background: var(--panel); border:1px solid var(--border); color: var(--fg); padding:12px 14px; border-radius:12px; resize:vertical; min-height:48px; max-height: 180px; }
    .btn { border:1px solid var(--border); background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); color: var(--fg); padding:10px 12px; border-radius:12px; cursor:pointer; display:inline-flex; align-items:center; gap:8px; }
    .btn:hover { border-color:#334155; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .switch { display:inline-flex; align-items:center; gap:8px; color:var(--muted); font-size:13px; }
    .switch select { background: var(--panel); color: var(--fg); border:1px solid var(--border); border-radius:10px; padding:6px 8px; }
    .footer { margin-top: 10px; color:var(--muted); font-size:12px; text-align:center; }
    .typing { color:var(--muted); font-style:italic; margin-left:46px; }
    .imgwrap { margin:8px 0 0 46px; }
    .imgwrap img { width: 320px; height: auto; border-radius:12px; border:1px solid var(--border); display:block; }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="avatar">üìö</div>
    <div class="brand">Smart Librarian</div>
    <span class="pill">RAG + Tool</span>
    <span class="pill">TTS/STT</span>
    <span class="pill">Images</span>
    <span class="pill">Streaming</span>
  </div>

  <div id="chat" class="chat"></div>

  <div class="composer">
    <textarea id="input" class="input" placeholder="Scrie sau apasƒÉ üéôÔ∏è pentru voce..."></textarea>
    <div class="row">
      <button id="micBtn" class="btn" title="Voice input (STT)">üéôÔ∏è<span class="lbl">Start</span></button>
      <button id="speakToggle" class="btn" title="Cite»ôte automat rƒÉspunsurile (TTS)">üîä Auto</button>
      <button id="autoImgToggle" class="btn" title="GenereazƒÉ automat imagine pentru fiecare rƒÉspuns">üñºÔ∏è Auto</button>
      <button id="sendBtn" class="btn" title="Trimite">‚û§ Trimite</button>
      <button id="clearBtn" class="btn" title="»òterge conversa»õia">üóëÔ∏è</button>
    </div>
    <!-- TTS: selector de voce -->
    <div class="row" style="margin-top:8px">
      <label class="switch">Voce:
        <select id="voiceSelect"></select>
      </label>
    </div>
  </div>

  <div class="footer">RƒÉspunsurile sosesc live (SSE). Po»õi genera automat imagini pentru fiecare rƒÉspuns (üñºÔ∏è Auto).</div>
</div>

<script>
  // ====== Elements & State ======
  const chatEl = document.getElementById('chat');
  const inputEl = document.getElementById('input');
  const sendBtn = document.getElementById('sendBtn');
  const clearBtn = document.getElementById('clearBtn');
  const micBtn = document.getElementById('micBtn');
  const speakToggle = document.getElementById('speakToggle');
  const autoImgToggle = document.getElementById('autoImgToggle');
  const voiceSelect = document.getElementById('voiceSelect');

  let autoSpeak = false;
  let autoImage = false;
  let recognizing = false;
  let recognition = null;

  // ====== UI Helpers ======
  function el(tag, cls, text) {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    if (text !== undefined) e.textContent = text;
    return e;
  }

  function addMessage(role, text, sources=null) {
    const row = el('div', 'msg');
    const av = el('div', 'avatar ' + (role==='user'?'user':''), role==='user'?'üôÇ':'ü§ñ');
    const bub = el('div', 'bubble ' + (role==='user'?'user':'bot'));
    bub.textContent = text;
    row.appendChild(av);
    row.appendChild(bub);
    chatEl.appendChild(row);

    if (role === 'assistant') {
      const actions = el('div','actions');
      const imgBtn = el('button','btn','üé® Imagine');
      imgBtn.onclick = () => generateImageForMessage(row, text);
      actions.appendChild(imgBtn);
      chatEl.appendChild(actions);
    }

    if (role==='assistant' && sources && sources.length) {
      appendSources(sources);
    }

    chatEl.scrollTop = chatEl.scrollHeight;

    if (role === 'assistant' && autoSpeak && 'speechSynthesis' in window) {
      speak(text);
    }
    if (role === 'assistant' && autoImage) {
      generateImageForMessage(row, text);
    }
  }

  function addAssistantPlaceholder() {
    const row = el('div', 'msg');
    const av = el('div', 'avatar', 'ü§ñ');
    const bub = el('div', 'bubble bot');
    row.appendChild(av);
    row.appendChild(bub);
    chatEl.appendChild(row);
    chatEl.scrollTop = chatEl.scrollHeight;
    return { row, bub };
  }

  function appendSources(sources) {
    const src = el('div','sources');
    src.textContent = 'Sources: ' + sources.map(s => `${s.title}`).join(' ‚Ä¢ ');
    chatEl.appendChild(src);
  }

  function setTyping(on) {
    let t = document.getElementById('typing');
    if (on) {
      if (!t) { t = el('div','typing'); t.id='typing'; t.textContent='Asistentul scrie...'; chatEl.appendChild(t); }
    } else {
      if (t) t.remove();
    }
    chatEl.scrollTop = chatEl.scrollHeight;
  }

  // ====== TTS helpers ======
  function splitIntoChunks(text, maxLen = 180) {
    const parts = [];
    const sentences = text
      .replace(/\s+/g,' ')
      .split(/([\.!\?;:])\s+/)
      .reduce((acc, cur) => {
        if (!acc.length) { acc.push(''); }
        if (/^[\.!\?;:]$/.test(cur)) acc[acc.length-1] += cur;
        else if (cur.trim()) acc.push(cur.trim());
        return acc;
      }, []).filter(Boolean);
    let buf = '';
    for (const s of sentences) {
      if ((buf + ' ' + s).trim().length <= maxLen) buf = (buf ? buf + ' ' : '') + s;
      else {
        if (buf) parts.push(buf);
        if (s.length > maxLen) {
          const chunks = s.split(/, /); let b = '';
          for (const c of chunks) {
            if ((b + ', ' + c).length <= maxLen) b = (b ? b + ', ' : '') + c;
            else { if (b) parts.push(b); b = c; }
          }
          if (b) parts.push(b);
          buf = '';
        } else buf = s;
      }
    }
    if (buf) parts.push(buf);
    return parts;
  }

  function populateVoices() {
    if (!('speechSynthesis' in window)) return;
    const all = window.speechSynthesis.getVoices() || [];
    const sorted = all.slice().sort((a,b) => {
      const ar = (a.lang||'').toLowerCase().startsWith('ro') ? -1 : 1;
      const br = (b.lang||'').toLowerCase().startsWith('ro') ? -1 : 1;
      if (ar !== br) return ar - br;
      return (a.name || '').localeCompare(b.name || '');
    });
    voiceSelect.innerHTML = '';
    sorted.forEach(v => {
      const opt = document.createElement('option');
      opt.value = v.name;
      opt.textContent = `${v.name} ‚Äî ${v.lang}`;
      voiceSelect.appendChild(opt);
    });
    const saved = localStorage.getItem('voiceName');
    const preferRo = sorted.find(v => (v.lang||'').toLowerCase().startsWith('ro'));
    const target = sorted.find(v => v.name === saved) || preferRo || sorted[0];
    if (target) {
      voiceSelect.value = target.name;
      localStorage.setItem('voiceName', target.name);
    }
  }
  if ('speechSynthesis' in window) {
    populateVoices();
    window.speechSynthesis.onvoiceschanged = populateVoices;
  }
  voiceSelect?.addEventListener('change', () => {
    localStorage.setItem('voiceName', voiceSelect.value);
  });

  function speak(text) {
    if (!('speechSynthesis' in window)) return;
    const synth = window.speechSynthesis; synth.cancel();
    const chosenName = voiceSelect?.value || localStorage.getItem('voiceName');
    const voices = synth.getVoices();
    let voice = voices.find(v => v.name === chosenName)
             || voices.find(v => (v.lang||'').toLowerCase().startsWith('ro'))
             || voices[0];
    const rate = 1.0, pitch = 1.0;
    const queue = splitIntoChunks(text, 180);
    const speakNext = () => {
      if (!queue.length) return;
      const u = new SpeechSynthesisUtterance(queue.shift());
      u.voice = voice || null;
      u.lang = (voice && voice.lang) ? voice.lang : 'ro-RO';
      u.rate = rate; u.pitch = pitch;
      u.onend = () => speakNext();
      synth.speak(u);
    };
    speakNext();
  }

  // ====== STT (Web Speech API) ======
  function initSTT() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return null;
    const r = new SR();
    r.lang = 'ro-RO';
    r.interimResults = false;
    r.maxAlternatives = 1;
    r.onresult = (ev) => { inputEl.value = ev.results[0][0].transcript; };
    r.onend = () => { recognizing = false; micBtn.querySelector('.lbl').textContent = 'Start'; micBtn.disabled = false; };
    r.onerror = () => { recognizing = false; micBtn.querySelector('.lbl').textContent = 'Start'; micBtn.disabled = false; };
    return r;
  }
  recognition = initSTT();

  // ====== Image Generation (client) ======
  async function generateImageForMessage(rowEl, assistantText) {
    const loader = el('div','typing'); loader.textContent = 'Se genereazƒÉ imaginea...';
    chatEl.appendChild(loader); chatEl.scrollTop = chatEl.scrollHeight;

    try {
      const res = await fetch('/api/image', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ text: assistantText })
      });
      if (!res.ok) {
        const e = await res.json().catch(()=>({detail:'Eroare la server'}));
        addMessage('assistant', `‚ö†Ô∏è ${e.detail || 'Eroare la generarea imaginii'}`);
        loader.remove(); return;
      }
      const data = await res.json();
      const wrap = el('div','imgwrap');
      const img = new Image();
      img.src = 'data:image/png;base64,' + data.image_b64;
      img.alt = data.title || 'CopertƒÉ';
      wrap.appendChild(img);
      chatEl.appendChild(wrap);
      chatEl.scrollTop = chatEl.scrollHeight;
    } catch (err) {
      addMessage('assistant', '‚ö†Ô∏è Nu am reu»ôit sƒÉ generez imaginea.');
    } finally {
      loader.remove();
    }
  }

  // ====== Streaming (SSE) ======
  function sendStreaming(text) {
    // adaugƒÉ mesajul userului
    addMessage('user', text);
    const { row, bub } = addAssistantPlaceholder();
    setTyping(true);

    let acc = ''; // acumulƒÉm rƒÉspunsul final
    let es;
    try {
      if (!window.EventSource) throw new Error('EventSource not supported');
      es = new EventSource(`/api/chat/stream?q=${encodeURIComponent(text)}`);

      es.addEventListener('sources', (ev) => {
        try {
          const data = JSON.parse(ev.data);
          if (data && data.sources && data.sources.length) {
            appendSources(data.sources);
          }
        } catch {}
      });

      es.onmessage = (ev) => {
        setTyping(false);
        if (ev.data === '[DONE]') {
          es.close();
          // ac»õiuni dupƒÉ ce s-a √Æncheiat streamul:
          const actions = el('div','actions');
          const imgBtn = el('button','btn','üé® Imagine');
          imgBtn.onclick = () => generateImageForMessage(row, acc);
          actions.appendChild(imgBtn);
          chatEl.appendChild(actions);

          if (autoSpeak) speak(acc);
          if (autoImage) generateImageForMessage(row, acc);
          return;
        }
        try {
          const data = JSON.parse(ev.data);
          const delta = data.delta || '';
          acc += (acc ? ' ' : '') + delta;
          bub.textContent = acc;
          chatEl.scrollTop = chatEl.scrollHeight;
        } catch {}
      };

      es.onerror = () => {
        setTyping(false);
        es && es.close();
        addMessage('assistant', '‚ö†Ô∏è Conexiunea de streaming a fost √ÆntreruptƒÉ. Re√ÆncercƒÉ.');
      };
    } catch (e) {
      // Fallback: non-stream
      setTyping(true);
      fetch('/api/chat', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({message: text})
      }).then(r => r.json()).then(data => {
        setTyping(false);
        bub.textContent = data.answer || '‚Äî';
        if (data.sources && data.sources.length) appendSources(data.sources);
        const actions = el('div','actions');
        const imgBtn = el('button','btn','üé® Imagine');
        imgBtn.onclick = () => generateImageForMessage(row, data.answer || '');
        actions.appendChild(imgBtn);
        chatEl.appendChild(actions);
        if (autoSpeak && data.answer) speak(data.answer);
        if (autoImage && data.answer) generateImageForMessage(row, data.answer);
      }).catch(() => {
        setTyping(false);
        addMessage('assistant', '‚ö†Ô∏è Eroare la /api/chat.');
      });
    }
  }

  // ====== Events ======
  sendBtn.onclick = () => {
    const text = inputEl.value.trim();
    if (!text) return;
    inputEl.value = '';
    sendStreaming(text);
  };

  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendBtn.click(); }
  });

  clearBtn.onclick = () => {
    chatEl.innerHTML = '';
    window.speechSynthesis && window.speechSynthesis.cancel();
  };

  speakToggle.onclick = () => {
    autoSpeak = !autoSpeak;
    speakToggle.style.borderColor = autoSpeak ? 'var(--accent)' : 'var(--border)';
    speakToggle.style.color = autoSpeak ? 'white' : 'var(--fg)';
  };

  autoImgToggle.onclick = () => {
    autoImage = !autoImage;
    autoImgToggle.style.borderColor = autoImage ? 'var(--accent)' : 'var(--border)';
    autoImgToggle.style.color = autoImage ? 'white' : 'var(--fg)';
  };

  // STT
  recognition = (function initSTT(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return null;
    const r = new SR();
    r.lang = 'ro-RO'; r.interimResults = false; r.maxAlternatives = 1;
    r.onresult = (ev) => { inputEl.value = ev.results[0][0].transcript; };
    r.onend = () => { recognizing = false; micBtn.querySelector('.lbl').textContent = 'Start'; micBtn.disabled = false; };
    r.onerror = () => { recognizing = false; micBtn.querySelector('.lbl').textContent = 'Start'; micBtn.disabled = false; };
    return r;
  })();

  micBtn.onclick = () => {
    if (!recognition) { addMessage('assistant', 'üéôÔ∏è Browserul tƒÉu nu suportƒÉ Speech Recognition.'); return; }
    if (!recognizing) {
      recognizing = true;
      micBtn.querySelector('.lbl').textContent = 'Stop';
      micBtn.disabled = true;
      try { recognition.start(); }
      catch(e) { recognizing = false; micBtn.querySelector('.lbl').textContent = 'Start'; micBtn.disabled = false; }
    }
  };

  // initialize voices
  if ('speechSynthesis' in window) {
    populateVoices();
    window.speechSynthesis.onvoiceschanged = populateVoices;
  }
  voiceSelect?.addEventListener('change', () => {
    localStorage.setItem('voiceName', voiceSelect.value);
  });
</script>
</body>
</html>
